"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-rnd";
exports.ids = ["vendor-chunks/react-rnd"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-rnd/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/react-rnd/lib/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Rnd: () => (/* binding */ Rnd)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_draggable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-draggable */ \"(ssr)/./node_modules/react-draggable/build/cjs/cjs.js\");\n/* harmony import */ var react_draggable__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_draggable__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var re_resizable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! re-resizable */ \"(ssr)/./node_modules/re-resizable/lib/index.js\");\n\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nvar resizableStyle = {\n    width: \"auto\",\n    height: \"auto\",\n    display: \"inline-block\",\n    position: \"absolute\",\n    top: 0,\n    left: 0,\n};\nvar getEnableResizingByFlag = function (flag) { return ({\n    bottom: flag,\n    bottomLeft: flag,\n    bottomRight: flag,\n    left: flag,\n    right: flag,\n    top: flag,\n    topLeft: flag,\n    topRight: flag,\n}); };\nvar Rnd = /** @class */ (function (_super) {\n    __extends(Rnd, _super);\n    function Rnd(props) {\n        var _this = _super.call(this, props) || this;\n        _this.resizingPosition = { x: 0, y: 0 };\n        _this.offsetFromParent = { left: 0, top: 0 };\n        _this.resizableElement = { current: null };\n        _this.originalPosition = { x: 0, y: 0 };\n        _this.refDraggable = function (c) {\n            if (!c)\n                return;\n            _this.draggable = c;\n        };\n        _this.refResizable = function (c) {\n            if (!c)\n                return;\n            _this.resizable = c;\n            _this.resizableElement.current = c.resizable;\n        };\n        _this.state = {\n            resizing: false,\n            bounds: {\n                top: 0,\n                right: 0,\n                bottom: 0,\n                left: 0,\n            },\n            maxWidth: props.maxWidth,\n            maxHeight: props.maxHeight,\n        };\n        _this.onResizeStart = _this.onResizeStart.bind(_this);\n        _this.onResize = _this.onResize.bind(_this);\n        _this.onResizeStop = _this.onResizeStop.bind(_this);\n        _this.onDragStart = _this.onDragStart.bind(_this);\n        _this.onDrag = _this.onDrag.bind(_this);\n        _this.onDragStop = _this.onDragStop.bind(_this);\n        _this.getMaxSizesFromProps = _this.getMaxSizesFromProps.bind(_this);\n        return _this;\n    }\n    Rnd.prototype.componentDidMount = function () {\n        this.updateOffsetFromParent();\n        var _a = this.offsetFromParent, left = _a.left, top = _a.top;\n        var _b = this.getDraggablePosition(), x = _b.x, y = _b.y;\n        this.draggable.setState({\n            x: x - left,\n            y: y - top,\n        });\n        // HACK: Apply position adjustment\n        this.forceUpdate();\n    };\n    // HACK: To get `react-draggable` state x and y.\n    Rnd.prototype.getDraggablePosition = function () {\n        var _a = this.draggable.state, x = _a.x, y = _a.y;\n        return { x: x, y: y };\n    };\n    Rnd.prototype.getParent = function () {\n        return this.resizable && this.resizable.parentNode;\n    };\n    Rnd.prototype.getParentSize = function () {\n        return this.resizable.getParentSize();\n    };\n    Rnd.prototype.getMaxSizesFromProps = function () {\n        var maxWidth = typeof this.props.maxWidth === \"undefined\" ? Number.MAX_SAFE_INTEGER : this.props.maxWidth;\n        var maxHeight = typeof this.props.maxHeight === \"undefined\" ? Number.MAX_SAFE_INTEGER : this.props.maxHeight;\n        return { maxWidth: maxWidth, maxHeight: maxHeight };\n    };\n    Rnd.prototype.getSelfElement = function () {\n        return this.resizable && this.resizable.resizable;\n    };\n    Rnd.prototype.getOffsetHeight = function (boundary) {\n        var scale = this.props.scale;\n        switch (this.props.bounds) {\n            case \"window\":\n                return window.innerHeight / scale;\n            case \"body\":\n                return document.body.offsetHeight / scale;\n            default:\n                return boundary.offsetHeight;\n        }\n    };\n    Rnd.prototype.getOffsetWidth = function (boundary) {\n        var scale = this.props.scale;\n        switch (this.props.bounds) {\n            case \"window\":\n                return window.innerWidth / scale;\n            case \"body\":\n                return document.body.offsetWidth / scale;\n            default:\n                return boundary.offsetWidth;\n        }\n    };\n    Rnd.prototype.onDragStart = function (e, data) {\n        if (this.props.onDragStart) {\n            this.props.onDragStart(e, data);\n        }\n        var pos = this.getDraggablePosition();\n        this.originalPosition = pos;\n        if (!this.props.bounds)\n            return;\n        var parent = this.getParent();\n        var scale = this.props.scale;\n        var boundary;\n        if (this.props.bounds === \"parent\") {\n            boundary = parent;\n        }\n        else if (this.props.bounds === \"body\") {\n            var parentRect_1 = parent.getBoundingClientRect();\n            var parentLeft_1 = parentRect_1.left;\n            var parentTop_1 = parentRect_1.top;\n            var bodyRect = document.body.getBoundingClientRect();\n            var left_1 = -(parentLeft_1 - parent.offsetLeft * scale - bodyRect.left) / scale;\n            var top_1 = -(parentTop_1 - parent.offsetTop * scale - bodyRect.top) / scale;\n            var right = (document.body.offsetWidth - this.resizable.size.width * scale) / scale + left_1;\n            var bottom = (document.body.offsetHeight - this.resizable.size.height * scale) / scale + top_1;\n            return this.setState({ bounds: { top: top_1, right: right, bottom: bottom, left: left_1 } });\n        }\n        else if (this.props.bounds === \"window\") {\n            if (!this.resizable)\n                return;\n            var parentRect_2 = parent.getBoundingClientRect();\n            var parentLeft_2 = parentRect_2.left;\n            var parentTop_2 = parentRect_2.top;\n            var left_2 = -(parentLeft_2 - parent.offsetLeft * scale) / scale;\n            var top_2 = -(parentTop_2 - parent.offsetTop * scale) / scale;\n            var right = (window.innerWidth - this.resizable.size.width * scale) / scale + left_2;\n            var bottom = (window.innerHeight - this.resizable.size.height * scale) / scale + top_2;\n            return this.setState({ bounds: { top: top_2, right: right, bottom: bottom, left: left_2 } });\n        }\n        else if (typeof this.props.bounds === \"string\") {\n            boundary = document.querySelector(this.props.bounds);\n        }\n        else if (this.props.bounds instanceof HTMLElement) {\n            boundary = this.props.bounds;\n        }\n        if (!(boundary instanceof HTMLElement) || !(parent instanceof HTMLElement)) {\n            return;\n        }\n        var boundaryRect = boundary.getBoundingClientRect();\n        var boundaryLeft = boundaryRect.left;\n        var boundaryTop = boundaryRect.top;\n        var parentRect = parent.getBoundingClientRect();\n        var parentLeft = parentRect.left;\n        var parentTop = parentRect.top;\n        var left = (boundaryLeft - parentLeft) / scale;\n        var top = boundaryTop - parentTop;\n        if (!this.resizable)\n            return;\n        this.updateOffsetFromParent();\n        var offset = this.offsetFromParent;\n        this.setState({\n            bounds: {\n                top: top - offset.top,\n                right: left + (boundary.offsetWidth - this.resizable.size.width) - offset.left / scale,\n                bottom: top + (boundary.offsetHeight - this.resizable.size.height) - offset.top,\n                left: left - offset.left / scale,\n            },\n        });\n    };\n    Rnd.prototype.onDrag = function (e, data) {\n        if (!this.props.onDrag)\n            return;\n        var _a = this.offsetFromParent, left = _a.left, top = _a.top;\n        if (!this.props.dragAxis || this.props.dragAxis === \"both\") {\n            return this.props.onDrag(e, __assign(__assign({}, data), { x: data.x + left, y: data.y + top }));\n        }\n        else if (this.props.dragAxis === \"x\") {\n            return this.props.onDrag(e, __assign(__assign({}, data), { x: data.x + left, y: this.originalPosition.y + top, deltaY: 0 }));\n        }\n        else if (this.props.dragAxis === \"y\") {\n            return this.props.onDrag(e, __assign(__assign({}, data), { x: this.originalPosition.x + left, y: data.y + top, deltaX: 0 }));\n        }\n    };\n    Rnd.prototype.onDragStop = function (e, data) {\n        if (!this.props.onDragStop)\n            return;\n        var _a = this.offsetFromParent, left = _a.left, top = _a.top;\n        if (!this.props.dragAxis || this.props.dragAxis === \"both\") {\n            return this.props.onDragStop(e, __assign(__assign({}, data), { x: data.x + left, y: data.y + top }));\n        }\n        else if (this.props.dragAxis === \"x\") {\n            return this.props.onDragStop(e, __assign(__assign({}, data), { x: data.x + left, y: this.originalPosition.y + top, deltaY: 0 }));\n        }\n        else if (this.props.dragAxis === \"y\") {\n            return this.props.onDragStop(e, __assign(__assign({}, data), { x: this.originalPosition.x + left, y: data.y + top, deltaX: 0 }));\n        }\n    };\n    Rnd.prototype.onResizeStart = function (e, dir, elementRef) {\n        e.stopPropagation();\n        this.setState({\n            resizing: true,\n        });\n        var scale = this.props.scale;\n        var offset = this.offsetFromParent;\n        var pos = this.getDraggablePosition();\n        this.resizingPosition = { x: pos.x + offset.left, y: pos.y + offset.top };\n        this.originalPosition = pos;\n        if (this.props.bounds) {\n            var parent_1 = this.getParent();\n            var boundary = void 0;\n            if (this.props.bounds === \"parent\") {\n                boundary = parent_1;\n            }\n            else if (this.props.bounds === \"body\") {\n                boundary = document.body;\n            }\n            else if (this.props.bounds === \"window\") {\n                boundary = window;\n            }\n            else if (typeof this.props.bounds === \"string\") {\n                boundary = document.querySelector(this.props.bounds);\n            }\n            else if (this.props.bounds instanceof HTMLElement) {\n                boundary = this.props.bounds;\n            }\n            var self_1 = this.getSelfElement();\n            if (self_1 instanceof Element &&\n                (boundary instanceof HTMLElement || boundary === window) &&\n                parent_1 instanceof HTMLElement) {\n                var _a = this.getMaxSizesFromProps(), maxWidth = _a.maxWidth, maxHeight = _a.maxHeight;\n                var parentSize = this.getParentSize();\n                if (maxWidth && typeof maxWidth === \"string\") {\n                    if (maxWidth.endsWith(\"%\")) {\n                        var ratio = Number(maxWidth.replace(\"%\", \"\")) / 100;\n                        maxWidth = parentSize.width * ratio;\n                    }\n                    else if (maxWidth.endsWith(\"px\")) {\n                        maxWidth = Number(maxWidth.replace(\"px\", \"\"));\n                    }\n                }\n                if (maxHeight && typeof maxHeight === \"string\") {\n                    if (maxHeight.endsWith(\"%\")) {\n                        var ratio = Number(maxHeight.replace(\"%\", \"\")) / 100;\n                        maxHeight = parentSize.height * ratio;\n                    }\n                    else if (maxHeight.endsWith(\"px\")) {\n                        maxHeight = Number(maxHeight.replace(\"px\", \"\"));\n                    }\n                }\n                var selfRect = self_1.getBoundingClientRect();\n                var selfLeft = selfRect.left;\n                var selfTop = selfRect.top;\n                var boundaryRect = this.props.bounds === \"window\" ? { left: 0, top: 0 } : boundary.getBoundingClientRect();\n                var boundaryLeft = boundaryRect.left;\n                var boundaryTop = boundaryRect.top;\n                var offsetWidth = this.getOffsetWidth(boundary);\n                var offsetHeight = this.getOffsetHeight(boundary);\n                var hasLeft = dir.toLowerCase().endsWith(\"left\");\n                var hasRight = dir.toLowerCase().endsWith(\"right\");\n                var hasTop = dir.startsWith(\"top\");\n                var hasBottom = dir.startsWith(\"bottom\");\n                if ((hasLeft || hasTop) && this.resizable) {\n                    var max = (selfLeft - boundaryLeft) / scale + this.resizable.size.width;\n                    this.setState({ maxWidth: max > Number(maxWidth) ? maxWidth : max });\n                }\n                // INFO: To set bounds in `lock aspect ratio with bounds` case. See also that story.\n                if (hasRight || (this.props.lockAspectRatio && !hasLeft && !hasTop)) {\n                    var max = offsetWidth + (boundaryLeft - selfLeft) / scale;\n                    this.setState({ maxWidth: max > Number(maxWidth) ? maxWidth : max });\n                }\n                if ((hasTop || hasLeft) && this.resizable) {\n                    var max = (selfTop - boundaryTop) / scale + this.resizable.size.height;\n                    this.setState({\n                        maxHeight: max > Number(maxHeight) ? maxHeight : max,\n                    });\n                }\n                // INFO: To set bounds in `lock aspect ratio with bounds` case. See also that story.\n                if (hasBottom || (this.props.lockAspectRatio && !hasTop && !hasLeft)) {\n                    var max = offsetHeight + (boundaryTop - selfTop) / scale;\n                    this.setState({\n                        maxHeight: max > Number(maxHeight) ? maxHeight : max,\n                    });\n                }\n            }\n        }\n        else {\n            this.setState({\n                maxWidth: this.props.maxWidth,\n                maxHeight: this.props.maxHeight,\n            });\n        }\n        if (this.props.onResizeStart) {\n            this.props.onResizeStart(e, dir, elementRef);\n        }\n    };\n    Rnd.prototype.onResize = function (e, direction, elementRef, delta) {\n        // INFO: Apply x and y position adjustments caused by resizing to draggable\n        var newPos = { x: this.originalPosition.x, y: this.originalPosition.y };\n        var left = -delta.width;\n        var top = -delta.height;\n        var directions = [\"top\", \"left\", \"topLeft\", \"bottomLeft\", \"topRight\"];\n        if (directions.includes(direction)) {\n            if (direction === \"bottomLeft\") {\n                newPos.x += left;\n            }\n            else if (direction === \"topRight\") {\n                newPos.y += top;\n            }\n            else {\n                newPos.x += left;\n                newPos.y += top;\n            }\n        }\n        var draggableState = this.draggable.state;\n        if (newPos.x !== draggableState.x || newPos.y !== draggableState.y) {\n            this.draggable.setState(newPos);\n        }\n        this.updateOffsetFromParent();\n        var offset = this.offsetFromParent;\n        var x = this.getDraggablePosition().x + offset.left;\n        var y = this.getDraggablePosition().y + offset.top;\n        this.resizingPosition = { x: x, y: y };\n        if (!this.props.onResize)\n            return;\n        this.props.onResize(e, direction, elementRef, delta, {\n            x: x,\n            y: y,\n        });\n    };\n    Rnd.prototype.onResizeStop = function (e, direction, elementRef, delta) {\n        this.setState({\n            resizing: false,\n        });\n        var _a = this.getMaxSizesFromProps(), maxWidth = _a.maxWidth, maxHeight = _a.maxHeight;\n        this.setState({ maxWidth: maxWidth, maxHeight: maxHeight });\n        if (this.props.onResizeStop) {\n            this.props.onResizeStop(e, direction, elementRef, delta, this.resizingPosition);\n        }\n    };\n    Rnd.prototype.updateSize = function (size) {\n        if (!this.resizable)\n            return;\n        this.resizable.updateSize({ width: size.width, height: size.height });\n    };\n    Rnd.prototype.updatePosition = function (position) {\n        this.draggable.setState(position);\n    };\n    Rnd.prototype.updateOffsetFromParent = function () {\n        var scale = this.props.scale;\n        var parent = this.getParent();\n        var self = this.getSelfElement();\n        if (!parent || self === null) {\n            return {\n                top: 0,\n                left: 0,\n            };\n        }\n        var parentRect = parent.getBoundingClientRect();\n        var parentLeft = parentRect.left;\n        var parentTop = parentRect.top;\n        var selfRect = self.getBoundingClientRect();\n        var position = this.getDraggablePosition();\n        var scrollLeft = parent.scrollLeft;\n        var scrollTop = parent.scrollTop;\n        this.offsetFromParent = {\n            left: selfRect.left - parentLeft + scrollLeft - position.x * scale,\n            top: selfRect.top - parentTop + scrollTop - position.y * scale,\n        };\n    };\n    Rnd.prototype.render = function () {\n        var _a = this.props, disableDragging = _a.disableDragging, style = _a.style, dragHandleClassName = _a.dragHandleClassName, position = _a.position, onMouseDown = _a.onMouseDown, onMouseUp = _a.onMouseUp, dragAxis = _a.dragAxis, dragGrid = _a.dragGrid, bounds = _a.bounds, enableUserSelectHack = _a.enableUserSelectHack, cancel = _a.cancel, children = _a.children, onResizeStart = _a.onResizeStart, onResize = _a.onResize, onResizeStop = _a.onResizeStop, onDragStart = _a.onDragStart, onDrag = _a.onDrag, onDragStop = _a.onDragStop, resizeHandleStyles = _a.resizeHandleStyles, resizeHandleClasses = _a.resizeHandleClasses, resizeHandleComponent = _a.resizeHandleComponent, enableResizing = _a.enableResizing, resizeGrid = _a.resizeGrid, resizeHandleWrapperClass = _a.resizeHandleWrapperClass, resizeHandleWrapperStyle = _a.resizeHandleWrapperStyle, scale = _a.scale, allowAnyClick = _a.allowAnyClick, resizableProps = __rest(_a, [\"disableDragging\", \"style\", \"dragHandleClassName\", \"position\", \"onMouseDown\", \"onMouseUp\", \"dragAxis\", \"dragGrid\", \"bounds\", \"enableUserSelectHack\", \"cancel\", \"children\", \"onResizeStart\", \"onResize\", \"onResizeStop\", \"onDragStart\", \"onDrag\", \"onDragStop\", \"resizeHandleStyles\", \"resizeHandleClasses\", \"resizeHandleComponent\", \"enableResizing\", \"resizeGrid\", \"resizeHandleWrapperClass\", \"resizeHandleWrapperStyle\", \"scale\", \"allowAnyClick\"]);\n        var defaultValue = this.props.default ? __assign({}, this.props.default) : undefined;\n        // Remove unknown props, see also https://reactjs.org/warnings/unknown-prop.html\n        delete resizableProps.default;\n        var cursorStyle = disableDragging || dragHandleClassName ? { cursor: \"auto\" } : { cursor: \"move\" };\n        var innerStyle = __assign(__assign(__assign({}, resizableStyle), cursorStyle), style);\n        var _b = this.offsetFromParent, left = _b.left, top = _b.top;\n        var draggablePosition;\n        if (position) {\n            draggablePosition = {\n                x: position.x - left,\n                y: position.y - top,\n            };\n        }\n        // INFO: Make uncontorolled component when resizing to control position by setPostion.\n        var pos = this.state.resizing ? undefined : draggablePosition;\n        var dragAxisOrUndefined = this.state.resizing ? \"both\" : dragAxis;\n        return ((0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)((react_draggable__WEBPACK_IMPORTED_MODULE_1___default()), { ref: this.refDraggable, handle: dragHandleClassName ? \".\".concat(dragHandleClassName) : undefined, defaultPosition: defaultValue, onMouseDown: onMouseDown, \n            // @ts-expect-error\n            onMouseUp: onMouseUp, onStart: this.onDragStart, onDrag: this.onDrag, onStop: this.onDragStop, axis: dragAxisOrUndefined, disabled: disableDragging, grid: dragGrid, bounds: bounds ? this.state.bounds : undefined, position: pos, enableUserSelectHack: enableUserSelectHack, cancel: cancel, scale: scale, allowAnyClick: allowAnyClick, nodeRef: this.resizableElement },\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(re_resizable__WEBPACK_IMPORTED_MODULE_2__.Resizable, __assign({}, resizableProps, { ref: this.refResizable, defaultSize: defaultValue, size: this.props.size, enable: typeof enableResizing === \"boolean\" ? getEnableResizingByFlag(enableResizing) : enableResizing, onResizeStart: this.onResizeStart, onResize: this.onResize, onResizeStop: this.onResizeStop, style: innerStyle, minWidth: this.props.minWidth, minHeight: this.props.minHeight, maxWidth: this.state.resizing ? this.state.maxWidth : this.props.maxWidth, maxHeight: this.state.resizing ? this.state.maxHeight : this.props.maxHeight, grid: resizeGrid, handleWrapperClass: resizeHandleWrapperClass, handleWrapperStyle: resizeHandleWrapperStyle, lockAspectRatio: this.props.lockAspectRatio, lockAspectRatioExtraWidth: this.props.lockAspectRatioExtraWidth, lockAspectRatioExtraHeight: this.props.lockAspectRatioExtraHeight, handleStyles: resizeHandleStyles, handleClasses: resizeHandleClasses, handleComponent: resizeHandleComponent, scale: this.props.scale }), children)));\n    };\n    Rnd.defaultProps = {\n        maxWidth: Number.MAX_SAFE_INTEGER,\n        maxHeight: Number.MAX_SAFE_INTEGER,\n        scale: 1,\n        onResizeStart: function () { },\n        onResize: function () { },\n        onResizeStop: function () { },\n        onDragStart: function () { },\n        onDrag: function () { },\n        onDragStop: function () { },\n    };\n    return Rnd;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm5kL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBcUQ7QUFDYjtBQUNDOztBQUV6QztBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDbkYsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxVQUFVLDBEQUEwRDtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVUsMERBQTBEO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsV0FBVyxtQ0FBbUM7QUFDMUc7QUFDQTtBQUNBLDREQUE0RCxXQUFXLCtEQUErRDtBQUN0STtBQUNBO0FBQ0EsNERBQTRELFdBQVcsK0RBQStEO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFdBQVcsbUNBQW1DO0FBQzlHO0FBQ0E7QUFDQSxnRUFBZ0UsV0FBVywrREFBK0Q7QUFDMUk7QUFDQTtBQUNBLGdFQUFnRSxXQUFXLCtEQUErRDtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGtCQUFrQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtREFBbUQ7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbURBQW1EO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdCQUF3QiwwQ0FBMEM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msd0NBQXdDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSxxRUFBcUUsaUJBQWlCLElBQUk7QUFDMUYsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0RBQWEsQ0FBQyx3REFBUyxJQUFJO0FBQzNDO0FBQ0Esd1hBQXdYO0FBQ3hYLFlBQVksb0RBQWEsQ0FBQyxtREFBUyxhQUFhLG9CQUFvQixpNkJBQWk2QjtBQUNyK0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxpQ0FBaUM7QUFDakMscUNBQXFDO0FBQ3JDLG9DQUFvQztBQUNwQywrQkFBK0I7QUFDL0IsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxDQUFDLENBQUMsZ0RBQWE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC8uL25vZGVfbW9kdWxlcy9yZWFjdC1ybmQvbGliL2luZGV4LmpzPzgxOGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBEcmFnZ2FibGUgZnJvbSAncmVhY3QtZHJhZ2dhYmxlJztcbmltcG9ydCB7IFJlc2l6YWJsZSB9IGZyb20gJ3JlLXJlc2l6YWJsZSc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cblxudmFyIHJlc2l6YWJsZVN0eWxlID0ge1xuICAgIHdpZHRoOiBcImF1dG9cIixcbiAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbn07XG52YXIgZ2V0RW5hYmxlUmVzaXppbmdCeUZsYWcgPSBmdW5jdGlvbiAoZmxhZykgeyByZXR1cm4gKHtcbiAgICBib3R0b206IGZsYWcsXG4gICAgYm90dG9tTGVmdDogZmxhZyxcbiAgICBib3R0b21SaWdodDogZmxhZyxcbiAgICBsZWZ0OiBmbGFnLFxuICAgIHJpZ2h0OiBmbGFnLFxuICAgIHRvcDogZmxhZyxcbiAgICB0b3BMZWZ0OiBmbGFnLFxuICAgIHRvcFJpZ2h0OiBmbGFnLFxufSk7IH07XG52YXIgUm5kID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSbmQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUm5kKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZXNpemluZ1Bvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIF90aGlzLm9mZnNldEZyb21QYXJlbnQgPSB7IGxlZnQ6IDAsIHRvcDogMCB9O1xuICAgICAgICBfdGhpcy5yZXNpemFibGVFbGVtZW50ID0geyBjdXJyZW50OiBudWxsIH07XG4gICAgICAgIF90aGlzLm9yaWdpbmFsUG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgX3RoaXMucmVmRHJhZ2dhYmxlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIGlmICghYylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBfdGhpcy5kcmFnZ2FibGUgPSBjO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZWZSZXNpemFibGUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgaWYgKCFjKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIF90aGlzLnJlc2l6YWJsZSA9IGM7XG4gICAgICAgICAgICBfdGhpcy5yZXNpemFibGVFbGVtZW50LmN1cnJlbnQgPSBjLnJlc2l6YWJsZTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICByZXNpemluZzogZmFsc2UsXG4gICAgICAgICAgICBib3VuZHM6IHtcbiAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF4V2lkdGg6IHByb3BzLm1heFdpZHRoLFxuICAgICAgICAgICAgbWF4SGVpZ2h0OiBwcm9wcy5tYXhIZWlnaHQsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uUmVzaXplU3RhcnQgPSBfdGhpcy5vblJlc2l6ZVN0YXJ0LmJpbmQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5vblJlc2l6ZSA9IF90aGlzLm9uUmVzaXplLmJpbmQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5vblJlc2l6ZVN0b3AgPSBfdGhpcy5vblJlc2l6ZVN0b3AuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLm9uRHJhZ1N0YXJ0ID0gX3RoaXMub25EcmFnU3RhcnQuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLm9uRHJhZyA9IF90aGlzLm9uRHJhZy5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMub25EcmFnU3RvcCA9IF90aGlzLm9uRHJhZ1N0b3AuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLmdldE1heFNpemVzRnJvbVByb3BzID0gX3RoaXMuZ2V0TWF4U2l6ZXNGcm9tUHJvcHMuYmluZChfdGhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUm5kLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVPZmZzZXRGcm9tUGFyZW50KCk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMub2Zmc2V0RnJvbVBhcmVudCwgbGVmdCA9IF9hLmxlZnQsIHRvcCA9IF9hLnRvcDtcbiAgICAgICAgdmFyIF9iID0gdGhpcy5nZXREcmFnZ2FibGVQb3NpdGlvbigpLCB4ID0gX2IueCwgeSA9IF9iLnk7XG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHg6IHggLSBsZWZ0LFxuICAgICAgICAgICAgeTogeSAtIHRvcCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEhBQ0s6IEFwcGx5IHBvc2l0aW9uIGFkanVzdG1lbnRcbiAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgIH07XG4gICAgLy8gSEFDSzogVG8gZ2V0IGByZWFjdC1kcmFnZ2FibGVgIHN0YXRlIHggYW5kIHkuXG4gICAgUm5kLnByb3RvdHlwZS5nZXREcmFnZ2FibGVQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5kcmFnZ2FibGUuc3RhdGUsIHggPSBfYS54LCB5ID0gX2EueTtcbiAgICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuICAgIH07XG4gICAgUm5kLnByb3RvdHlwZS5nZXRQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6YWJsZSAmJiB0aGlzLnJlc2l6YWJsZS5wYXJlbnROb2RlO1xuICAgIH07XG4gICAgUm5kLnByb3RvdHlwZS5nZXRQYXJlbnRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemFibGUuZ2V0UGFyZW50U2l6ZSgpO1xuICAgIH07XG4gICAgUm5kLnByb3RvdHlwZS5nZXRNYXhTaXplc0Zyb21Qcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1heFdpZHRoID0gdHlwZW9mIHRoaXMucHJvcHMubWF4V2lkdGggPT09IFwidW5kZWZpbmVkXCIgPyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA6IHRoaXMucHJvcHMubWF4V2lkdGg7XG4gICAgICAgIHZhciBtYXhIZWlnaHQgPSB0eXBlb2YgdGhpcy5wcm9wcy5tYXhIZWlnaHQgPT09IFwidW5kZWZpbmVkXCIgPyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA6IHRoaXMucHJvcHMubWF4SGVpZ2h0O1xuICAgICAgICByZXR1cm4geyBtYXhXaWR0aDogbWF4V2lkdGgsIG1heEhlaWdodDogbWF4SGVpZ2h0IH07XG4gICAgfTtcbiAgICBSbmQucHJvdG90eXBlLmdldFNlbGZFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemFibGUgJiYgdGhpcy5yZXNpemFibGUucmVzaXphYmxlO1xuICAgIH07XG4gICAgUm5kLnByb3RvdHlwZS5nZXRPZmZzZXRIZWlnaHQgPSBmdW5jdGlvbiAoYm91bmRhcnkpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5wcm9wcy5zY2FsZTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnByb3BzLmJvdW5kcykge1xuICAgICAgICAgICAgY2FzZSBcIndpbmRvd1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQgLyBzY2FsZTtcbiAgICAgICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0IC8gc2NhbGU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBib3VuZGFyeS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJuZC5wcm90b3R5cGUuZ2V0T2Zmc2V0V2lkdGggPSBmdW5jdGlvbiAoYm91bmRhcnkpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5wcm9wcy5zY2FsZTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnByb3BzLmJvdW5kcykge1xuICAgICAgICAgICAgY2FzZSBcIndpbmRvd1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aCAvIHNjYWxlO1xuICAgICAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCAvIHNjYWxlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYm91bmRhcnkub2Zmc2V0V2lkdGg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJuZC5wcm90b3R5cGUub25EcmFnU3RhcnQgPSBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkRyYWdTdGFydCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkRyYWdTdGFydChlLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXREcmFnZ2FibGVQb3NpdGlvbigpO1xuICAgICAgICB0aGlzLm9yaWdpbmFsUG9zaXRpb24gPSBwb3M7XG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5ib3VuZHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnByb3BzLnNjYWxlO1xuICAgICAgICB2YXIgYm91bmRhcnk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmJvdW5kcyA9PT0gXCJwYXJlbnRcIikge1xuICAgICAgICAgICAgYm91bmRhcnkgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wcy5ib3VuZHMgPT09IFwiYm9keVwiKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50UmVjdF8xID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIHBhcmVudExlZnRfMSA9IHBhcmVudFJlY3RfMS5sZWZ0O1xuICAgICAgICAgICAgdmFyIHBhcmVudFRvcF8xID0gcGFyZW50UmVjdF8xLnRvcDtcbiAgICAgICAgICAgIHZhciBib2R5UmVjdCA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB2YXIgbGVmdF8xID0gLShwYXJlbnRMZWZ0XzEgLSBwYXJlbnQub2Zmc2V0TGVmdCAqIHNjYWxlIC0gYm9keVJlY3QubGVmdCkgLyBzY2FsZTtcbiAgICAgICAgICAgIHZhciB0b3BfMSA9IC0ocGFyZW50VG9wXzEgLSBwYXJlbnQub2Zmc2V0VG9wICogc2NhbGUgLSBib2R5UmVjdC50b3ApIC8gc2NhbGU7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSAoZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCAtIHRoaXMucmVzaXphYmxlLnNpemUud2lkdGggKiBzY2FsZSkgLyBzY2FsZSArIGxlZnRfMTtcbiAgICAgICAgICAgIHZhciBib3R0b20gPSAoZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQgLSB0aGlzLnJlc2l6YWJsZS5zaXplLmhlaWdodCAqIHNjYWxlKSAvIHNjYWxlICsgdG9wXzE7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRTdGF0ZSh7IGJvdW5kczogeyB0b3A6IHRvcF8xLCByaWdodDogcmlnaHQsIGJvdHRvbTogYm90dG9tLCBsZWZ0OiBsZWZ0XzEgfSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BzLmJvdW5kcyA9PT0gXCJ3aW5kb3dcIikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlc2l6YWJsZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgcGFyZW50UmVjdF8yID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIHBhcmVudExlZnRfMiA9IHBhcmVudFJlY3RfMi5sZWZ0O1xuICAgICAgICAgICAgdmFyIHBhcmVudFRvcF8yID0gcGFyZW50UmVjdF8yLnRvcDtcbiAgICAgICAgICAgIHZhciBsZWZ0XzIgPSAtKHBhcmVudExlZnRfMiAtIHBhcmVudC5vZmZzZXRMZWZ0ICogc2NhbGUpIC8gc2NhbGU7XG4gICAgICAgICAgICB2YXIgdG9wXzIgPSAtKHBhcmVudFRvcF8yIC0gcGFyZW50Lm9mZnNldFRvcCAqIHNjYWxlKSAvIHNjYWxlO1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gKHdpbmRvdy5pbm5lcldpZHRoIC0gdGhpcy5yZXNpemFibGUuc2l6ZS53aWR0aCAqIHNjYWxlKSAvIHNjYWxlICsgbGVmdF8yO1xuICAgICAgICAgICAgdmFyIGJvdHRvbSA9ICh3aW5kb3cuaW5uZXJIZWlnaHQgLSB0aGlzLnJlc2l6YWJsZS5zaXplLmhlaWdodCAqIHNjYWxlKSAvIHNjYWxlICsgdG9wXzI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRTdGF0ZSh7IGJvdW5kczogeyB0b3A6IHRvcF8yLCByaWdodDogcmlnaHQsIGJvdHRvbTogYm90dG9tLCBsZWZ0OiBsZWZ0XzIgfSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5wcm9wcy5ib3VuZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGJvdW5kYXJ5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLnByb3BzLmJvdW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wcy5ib3VuZHMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgYm91bmRhcnkgPSB0aGlzLnByb3BzLmJvdW5kcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShib3VuZGFyeSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB8fCAhKHBhcmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBib3VuZGFyeVJlY3QgPSBib3VuZGFyeS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIGJvdW5kYXJ5TGVmdCA9IGJvdW5kYXJ5UmVjdC5sZWZ0O1xuICAgICAgICB2YXIgYm91bmRhcnlUb3AgPSBib3VuZGFyeVJlY3QudG9wO1xuICAgICAgICB2YXIgcGFyZW50UmVjdCA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHBhcmVudExlZnQgPSBwYXJlbnRSZWN0LmxlZnQ7XG4gICAgICAgIHZhciBwYXJlbnRUb3AgPSBwYXJlbnRSZWN0LnRvcDtcbiAgICAgICAgdmFyIGxlZnQgPSAoYm91bmRhcnlMZWZ0IC0gcGFyZW50TGVmdCkgLyBzY2FsZTtcbiAgICAgICAgdmFyIHRvcCA9IGJvdW5kYXJ5VG9wIC0gcGFyZW50VG9wO1xuICAgICAgICBpZiAoIXRoaXMucmVzaXphYmxlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnVwZGF0ZU9mZnNldEZyb21QYXJlbnQoKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0RnJvbVBhcmVudDtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBib3VuZHM6IHtcbiAgICAgICAgICAgICAgICB0b3A6IHRvcCAtIG9mZnNldC50b3AsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGxlZnQgKyAoYm91bmRhcnkub2Zmc2V0V2lkdGggLSB0aGlzLnJlc2l6YWJsZS5zaXplLndpZHRoKSAtIG9mZnNldC5sZWZ0IC8gc2NhbGUsXG4gICAgICAgICAgICAgICAgYm90dG9tOiB0b3AgKyAoYm91bmRhcnkub2Zmc2V0SGVpZ2h0IC0gdGhpcy5yZXNpemFibGUuc2l6ZS5oZWlnaHQpIC0gb2Zmc2V0LnRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0IC0gb2Zmc2V0LmxlZnQgLyBzY2FsZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUm5kLnByb3RvdHlwZS5vbkRyYWcgPSBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMub25EcmFnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLm9mZnNldEZyb21QYXJlbnQsIGxlZnQgPSBfYS5sZWZ0LCB0b3AgPSBfYS50b3A7XG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5kcmFnQXhpcyB8fCB0aGlzLnByb3BzLmRyYWdBeGlzID09PSBcImJvdGhcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMub25EcmFnKGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXRhKSwgeyB4OiBkYXRhLnggKyBsZWZ0LCB5OiBkYXRhLnkgKyB0b3AgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucHJvcHMuZHJhZ0F4aXMgPT09IFwieFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5vbkRyYWcoZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGEpLCB7IHg6IGRhdGEueCArIGxlZnQsIHk6IHRoaXMub3JpZ2luYWxQb3NpdGlvbi55ICsgdG9wLCBkZWx0YVk6IDAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucHJvcHMuZHJhZ0F4aXMgPT09IFwieVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5vbkRyYWcoZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGEpLCB7IHg6IHRoaXMub3JpZ2luYWxQb3NpdGlvbi54ICsgbGVmdCwgeTogZGF0YS55ICsgdG9wLCBkZWx0YVg6IDAgfSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSbmQucHJvdG90eXBlLm9uRHJhZ1N0b3AgPSBmdW5jdGlvbiAoZSwgZGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMub25EcmFnU3RvcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5vZmZzZXRGcm9tUGFyZW50LCBsZWZ0ID0gX2EubGVmdCwgdG9wID0gX2EudG9wO1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMuZHJhZ0F4aXMgfHwgdGhpcy5wcm9wcy5kcmFnQXhpcyA9PT0gXCJib3RoXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLm9uRHJhZ1N0b3AoZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGEpLCB7IHg6IGRhdGEueCArIGxlZnQsIHk6IGRhdGEueSArIHRvcCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wcy5kcmFnQXhpcyA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLm9uRHJhZ1N0b3AoZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGEpLCB7IHg6IGRhdGEueCArIGxlZnQsIHk6IHRoaXMub3JpZ2luYWxQb3NpdGlvbi55ICsgdG9wLCBkZWx0YVk6IDAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucHJvcHMuZHJhZ0F4aXMgPT09IFwieVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5vbkRyYWdTdG9wKGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXRhKSwgeyB4OiB0aGlzLm9yaWdpbmFsUG9zaXRpb24ueCArIGxlZnQsIHk6IGRhdGEueSArIHRvcCwgZGVsdGFYOiAwIH0pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUm5kLnByb3RvdHlwZS5vblJlc2l6ZVN0YXJ0ID0gZnVuY3Rpb24gKGUsIGRpciwgZWxlbWVudFJlZikge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHJlc2l6aW5nOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5wcm9wcy5zY2FsZTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0RnJvbVBhcmVudDtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0RHJhZ2dhYmxlUG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5yZXNpemluZ1Bvc2l0aW9uID0geyB4OiBwb3MueCArIG9mZnNldC5sZWZ0LCB5OiBwb3MueSArIG9mZnNldC50b3AgfTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFBvc2l0aW9uID0gcG9zO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5ib3VuZHMpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgICAgICAgICB2YXIgYm91bmRhcnkgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5ib3VuZHMgPT09IFwicGFyZW50XCIpIHtcbiAgICAgICAgICAgICAgICBib3VuZGFyeSA9IHBhcmVudF8xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wcy5ib3VuZHMgPT09IFwiYm9keVwiKSB7XG4gICAgICAgICAgICAgICAgYm91bmRhcnkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wcy5ib3VuZHMgPT09IFwid2luZG93XCIpIHtcbiAgICAgICAgICAgICAgICBib3VuZGFyeSA9IHdpbmRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLnByb3BzLmJvdW5kcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGJvdW5kYXJ5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLnByb3BzLmJvdW5kcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BzLmJvdW5kcyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgYm91bmRhcnkgPSB0aGlzLnByb3BzLmJvdW5kcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzZWxmXzEgPSB0aGlzLmdldFNlbGZFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAoc2VsZl8xIGluc3RhbmNlb2YgRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgIChib3VuZGFyeSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IGJvdW5kYXJ5ID09PSB3aW5kb3cpICYmXG4gICAgICAgICAgICAgICAgcGFyZW50XzEgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0TWF4U2l6ZXNGcm9tUHJvcHMoKSwgbWF4V2lkdGggPSBfYS5tYXhXaWR0aCwgbWF4SGVpZ2h0ID0gX2EubWF4SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRTaXplID0gdGhpcy5nZXRQYXJlbnRTaXplKCk7XG4gICAgICAgICAgICAgICAgaWYgKG1heFdpZHRoICYmIHR5cGVvZiBtYXhXaWR0aCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF4V2lkdGguZW5kc1dpdGgoXCIlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF0aW8gPSBOdW1iZXIobWF4V2lkdGgucmVwbGFjZShcIiVcIiwgXCJcIikpIC8gMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGggPSBwYXJlbnRTaXplLndpZHRoICogcmF0aW87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWF4V2lkdGguZW5kc1dpdGgoXCJweFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGggPSBOdW1iZXIobWF4V2lkdGgucmVwbGFjZShcInB4XCIsIFwiXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWF4SGVpZ2h0ICYmIHR5cGVvZiBtYXhIZWlnaHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heEhlaWdodC5lbmRzV2l0aChcIiVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXRpbyA9IE51bWJlcihtYXhIZWlnaHQucmVwbGFjZShcIiVcIiwgXCJcIikpIC8gMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0ID0gcGFyZW50U2l6ZS5oZWlnaHQgKiByYXRpbztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXhIZWlnaHQuZW5kc1dpdGgoXCJweFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0ID0gTnVtYmVyKG1heEhlaWdodC5yZXBsYWNlKFwicHhcIiwgXCJcIikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzZWxmUmVjdCA9IHNlbGZfMS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZkxlZnQgPSBzZWxmUmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgIHZhciBzZWxmVG9wID0gc2VsZlJlY3QudG9wO1xuICAgICAgICAgICAgICAgIHZhciBib3VuZGFyeVJlY3QgPSB0aGlzLnByb3BzLmJvdW5kcyA9PT0gXCJ3aW5kb3dcIiA/IHsgbGVmdDogMCwgdG9wOiAwIH0gOiBib3VuZGFyeS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRhcnlMZWZ0ID0gYm91bmRhcnlSZWN0LmxlZnQ7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kYXJ5VG9wID0gYm91bmRhcnlSZWN0LnRvcDtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0V2lkdGggPSB0aGlzLmdldE9mZnNldFdpZHRoKGJvdW5kYXJ5KTtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0SGVpZ2h0ID0gdGhpcy5nZXRPZmZzZXRIZWlnaHQoYm91bmRhcnkpO1xuICAgICAgICAgICAgICAgIHZhciBoYXNMZWZ0ID0gZGlyLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoXCJsZWZ0XCIpO1xuICAgICAgICAgICAgICAgIHZhciBoYXNSaWdodCA9IGRpci50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKFwicmlnaHRcIik7XG4gICAgICAgICAgICAgICAgdmFyIGhhc1RvcCA9IGRpci5zdGFydHNXaXRoKFwidG9wXCIpO1xuICAgICAgICAgICAgICAgIHZhciBoYXNCb3R0b20gPSBkaXIuc3RhcnRzV2l0aChcImJvdHRvbVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoKGhhc0xlZnQgfHwgaGFzVG9wKSAmJiB0aGlzLnJlc2l6YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ID0gKHNlbGZMZWZ0IC0gYm91bmRhcnlMZWZ0KSAvIHNjYWxlICsgdGhpcy5yZXNpemFibGUuc2l6ZS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IG1heFdpZHRoOiBtYXggPiBOdW1iZXIobWF4V2lkdGgpID8gbWF4V2lkdGggOiBtYXggfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElORk86IFRvIHNldCBib3VuZHMgaW4gYGxvY2sgYXNwZWN0IHJhdGlvIHdpdGggYm91bmRzYCBjYXNlLiBTZWUgYWxzbyB0aGF0IHN0b3J5LlxuICAgICAgICAgICAgICAgIGlmIChoYXNSaWdodCB8fCAodGhpcy5wcm9wcy5sb2NrQXNwZWN0UmF0aW8gJiYgIWhhc0xlZnQgJiYgIWhhc1RvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heCA9IG9mZnNldFdpZHRoICsgKGJvdW5kYXJ5TGVmdCAtIHNlbGZMZWZ0KSAvIHNjYWxlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgbWF4V2lkdGg6IG1heCA+IE51bWJlcihtYXhXaWR0aCkgPyBtYXhXaWR0aCA6IG1heCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChoYXNUb3AgfHwgaGFzTGVmdCkgJiYgdGhpcy5yZXNpemFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heCA9IChzZWxmVG9wIC0gYm91bmRhcnlUb3ApIC8gc2NhbGUgKyB0aGlzLnJlc2l6YWJsZS5zaXplLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IG1heCA+IE51bWJlcihtYXhIZWlnaHQpID8gbWF4SGVpZ2h0IDogbWF4LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSU5GTzogVG8gc2V0IGJvdW5kcyBpbiBgbG9jayBhc3BlY3QgcmF0aW8gd2l0aCBib3VuZHNgIGNhc2UuIFNlZSBhbHNvIHRoYXQgc3RvcnkuXG4gICAgICAgICAgICAgICAgaWYgKGhhc0JvdHRvbSB8fCAodGhpcy5wcm9wcy5sb2NrQXNwZWN0UmF0aW8gJiYgIWhhc1RvcCAmJiAhaGFzTGVmdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heCA9IG9mZnNldEhlaWdodCArIChib3VuZGFyeVRvcCAtIHNlbGZUb3ApIC8gc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiBtYXggPiBOdW1iZXIobWF4SGVpZ2h0KSA/IG1heEhlaWdodCA6IG1heCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgbWF4V2lkdGg6IHRoaXMucHJvcHMubWF4V2lkdGgsXG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiB0aGlzLnByb3BzLm1heEhlaWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uUmVzaXplU3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25SZXNpemVTdGFydChlLCBkaXIsIGVsZW1lbnRSZWYpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSbmQucHJvdG90eXBlLm9uUmVzaXplID0gZnVuY3Rpb24gKGUsIGRpcmVjdGlvbiwgZWxlbWVudFJlZiwgZGVsdGEpIHtcbiAgICAgICAgLy8gSU5GTzogQXBwbHkgeCBhbmQgeSBwb3NpdGlvbiBhZGp1c3RtZW50cyBjYXVzZWQgYnkgcmVzaXppbmcgdG8gZHJhZ2dhYmxlXG4gICAgICAgIHZhciBuZXdQb3MgPSB7IHg6IHRoaXMub3JpZ2luYWxQb3NpdGlvbi54LCB5OiB0aGlzLm9yaWdpbmFsUG9zaXRpb24ueSB9O1xuICAgICAgICB2YXIgbGVmdCA9IC1kZWx0YS53aWR0aDtcbiAgICAgICAgdmFyIHRvcCA9IC1kZWx0YS5oZWlnaHQ7XG4gICAgICAgIHZhciBkaXJlY3Rpb25zID0gW1widG9wXCIsIFwibGVmdFwiLCBcInRvcExlZnRcIiwgXCJib3R0b21MZWZ0XCIsIFwidG9wUmlnaHRcIl07XG4gICAgICAgIGlmIChkaXJlY3Rpb25zLmluY2x1ZGVzKGRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwiYm90dG9tTGVmdFwiKSB7XG4gICAgICAgICAgICAgICAgbmV3UG9zLnggKz0gbGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gXCJ0b3BSaWdodFwiKSB7XG4gICAgICAgICAgICAgICAgbmV3UG9zLnkgKz0gdG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3UG9zLnggKz0gbGVmdDtcbiAgICAgICAgICAgICAgICBuZXdQb3MueSArPSB0b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRyYWdnYWJsZVN0YXRlID0gdGhpcy5kcmFnZ2FibGUuc3RhdGU7XG4gICAgICAgIGlmIChuZXdQb3MueCAhPT0gZHJhZ2dhYmxlU3RhdGUueCB8fCBuZXdQb3MueSAhPT0gZHJhZ2dhYmxlU3RhdGUueSkge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2FibGUuc2V0U3RhdGUobmV3UG9zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZU9mZnNldEZyb21QYXJlbnQoKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0RnJvbVBhcmVudDtcbiAgICAgICAgdmFyIHggPSB0aGlzLmdldERyYWdnYWJsZVBvc2l0aW9uKCkueCArIG9mZnNldC5sZWZ0O1xuICAgICAgICB2YXIgeSA9IHRoaXMuZ2V0RHJhZ2dhYmxlUG9zaXRpb24oKS55ICsgb2Zmc2V0LnRvcDtcbiAgICAgICAgdGhpcy5yZXNpemluZ1Bvc2l0aW9uID0geyB4OiB4LCB5OiB5IH07XG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5vblJlc2l6ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5wcm9wcy5vblJlc2l6ZShlLCBkaXJlY3Rpb24sIGVsZW1lbnRSZWYsIGRlbHRhLCB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSbmQucHJvdG90eXBlLm9uUmVzaXplU3RvcCA9IGZ1bmN0aW9uIChlLCBkaXJlY3Rpb24sIGVsZW1lbnRSZWYsIGRlbHRhKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgcmVzaXppbmc6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5nZXRNYXhTaXplc0Zyb21Qcm9wcygpLCBtYXhXaWR0aCA9IF9hLm1heFdpZHRoLCBtYXhIZWlnaHQgPSBfYS5tYXhIZWlnaHQ7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBtYXhXaWR0aDogbWF4V2lkdGgsIG1heEhlaWdodDogbWF4SGVpZ2h0IH0pO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5vblJlc2l6ZVN0b3ApIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25SZXNpemVTdG9wKGUsIGRpcmVjdGlvbiwgZWxlbWVudFJlZiwgZGVsdGEsIHRoaXMucmVzaXppbmdQb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJuZC5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIGlmICghdGhpcy5yZXNpemFibGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmVzaXphYmxlLnVwZGF0ZVNpemUoeyB3aWR0aDogc2l6ZS53aWR0aCwgaGVpZ2h0OiBzaXplLmhlaWdodCB9KTtcbiAgICB9O1xuICAgIFJuZC5wcm90b3R5cGUudXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5kcmFnZ2FibGUuc2V0U3RhdGUocG9zaXRpb24pO1xuICAgIH07XG4gICAgUm5kLnByb3RvdHlwZS51cGRhdGVPZmZzZXRGcm9tUGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnByb3BzLnNjYWxlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLmdldFNlbGZFbGVtZW50KCk7XG4gICAgICAgIGlmICghcGFyZW50IHx8IHNlbGYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJlbnRSZWN0ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgcGFyZW50TGVmdCA9IHBhcmVudFJlY3QubGVmdDtcbiAgICAgICAgdmFyIHBhcmVudFRvcCA9IHBhcmVudFJlY3QudG9wO1xuICAgICAgICB2YXIgc2VsZlJlY3QgPSBzZWxmLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmdldERyYWdnYWJsZVBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gcGFyZW50LnNjcm9sbExlZnQ7XG4gICAgICAgIHZhciBzY3JvbGxUb3AgPSBwYXJlbnQuc2Nyb2xsVG9wO1xuICAgICAgICB0aGlzLm9mZnNldEZyb21QYXJlbnQgPSB7XG4gICAgICAgICAgICBsZWZ0OiBzZWxmUmVjdC5sZWZ0IC0gcGFyZW50TGVmdCArIHNjcm9sbExlZnQgLSBwb3NpdGlvbi54ICogc2NhbGUsXG4gICAgICAgICAgICB0b3A6IHNlbGZSZWN0LnRvcCAtIHBhcmVudFRvcCArIHNjcm9sbFRvcCAtIHBvc2l0aW9uLnkgKiBzY2FsZSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFJuZC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBkaXNhYmxlRHJhZ2dpbmcgPSBfYS5kaXNhYmxlRHJhZ2dpbmcsIHN0eWxlID0gX2Euc3R5bGUsIGRyYWdIYW5kbGVDbGFzc05hbWUgPSBfYS5kcmFnSGFuZGxlQ2xhc3NOYW1lLCBwb3NpdGlvbiA9IF9hLnBvc2l0aW9uLCBvbk1vdXNlRG93biA9IF9hLm9uTW91c2VEb3duLCBvbk1vdXNlVXAgPSBfYS5vbk1vdXNlVXAsIGRyYWdBeGlzID0gX2EuZHJhZ0F4aXMsIGRyYWdHcmlkID0gX2EuZHJhZ0dyaWQsIGJvdW5kcyA9IF9hLmJvdW5kcywgZW5hYmxlVXNlclNlbGVjdEhhY2sgPSBfYS5lbmFibGVVc2VyU2VsZWN0SGFjaywgY2FuY2VsID0gX2EuY2FuY2VsLCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBvblJlc2l6ZVN0YXJ0ID0gX2Eub25SZXNpemVTdGFydCwgb25SZXNpemUgPSBfYS5vblJlc2l6ZSwgb25SZXNpemVTdG9wID0gX2Eub25SZXNpemVTdG9wLCBvbkRyYWdTdGFydCA9IF9hLm9uRHJhZ1N0YXJ0LCBvbkRyYWcgPSBfYS5vbkRyYWcsIG9uRHJhZ1N0b3AgPSBfYS5vbkRyYWdTdG9wLCByZXNpemVIYW5kbGVTdHlsZXMgPSBfYS5yZXNpemVIYW5kbGVTdHlsZXMsIHJlc2l6ZUhhbmRsZUNsYXNzZXMgPSBfYS5yZXNpemVIYW5kbGVDbGFzc2VzLCByZXNpemVIYW5kbGVDb21wb25lbnQgPSBfYS5yZXNpemVIYW5kbGVDb21wb25lbnQsIGVuYWJsZVJlc2l6aW5nID0gX2EuZW5hYmxlUmVzaXppbmcsIHJlc2l6ZUdyaWQgPSBfYS5yZXNpemVHcmlkLCByZXNpemVIYW5kbGVXcmFwcGVyQ2xhc3MgPSBfYS5yZXNpemVIYW5kbGVXcmFwcGVyQ2xhc3MsIHJlc2l6ZUhhbmRsZVdyYXBwZXJTdHlsZSA9IF9hLnJlc2l6ZUhhbmRsZVdyYXBwZXJTdHlsZSwgc2NhbGUgPSBfYS5zY2FsZSwgYWxsb3dBbnlDbGljayA9IF9hLmFsbG93QW55Q2xpY2ssIHJlc2l6YWJsZVByb3BzID0gX19yZXN0KF9hLCBbXCJkaXNhYmxlRHJhZ2dpbmdcIiwgXCJzdHlsZVwiLCBcImRyYWdIYW5kbGVDbGFzc05hbWVcIiwgXCJwb3NpdGlvblwiLCBcIm9uTW91c2VEb3duXCIsIFwib25Nb3VzZVVwXCIsIFwiZHJhZ0F4aXNcIiwgXCJkcmFnR3JpZFwiLCBcImJvdW5kc1wiLCBcImVuYWJsZVVzZXJTZWxlY3RIYWNrXCIsIFwiY2FuY2VsXCIsIFwiY2hpbGRyZW5cIiwgXCJvblJlc2l6ZVN0YXJ0XCIsIFwib25SZXNpemVcIiwgXCJvblJlc2l6ZVN0b3BcIiwgXCJvbkRyYWdTdGFydFwiLCBcIm9uRHJhZ1wiLCBcIm9uRHJhZ1N0b3BcIiwgXCJyZXNpemVIYW5kbGVTdHlsZXNcIiwgXCJyZXNpemVIYW5kbGVDbGFzc2VzXCIsIFwicmVzaXplSGFuZGxlQ29tcG9uZW50XCIsIFwiZW5hYmxlUmVzaXppbmdcIiwgXCJyZXNpemVHcmlkXCIsIFwicmVzaXplSGFuZGxlV3JhcHBlckNsYXNzXCIsIFwicmVzaXplSGFuZGxlV3JhcHBlclN0eWxlXCIsIFwic2NhbGVcIiwgXCJhbGxvd0FueUNsaWNrXCJdKTtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHRoaXMucHJvcHMuZGVmYXVsdCA/IF9fYXNzaWduKHt9LCB0aGlzLnByb3BzLmRlZmF1bHQpIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBSZW1vdmUgdW5rbm93biBwcm9wcywgc2VlIGFsc28gaHR0cHM6Ly9yZWFjdGpzLm9yZy93YXJuaW5ncy91bmtub3duLXByb3AuaHRtbFxuICAgICAgICBkZWxldGUgcmVzaXphYmxlUHJvcHMuZGVmYXVsdDtcbiAgICAgICAgdmFyIGN1cnNvclN0eWxlID0gZGlzYWJsZURyYWdnaW5nIHx8IGRyYWdIYW5kbGVDbGFzc05hbWUgPyB7IGN1cnNvcjogXCJhdXRvXCIgfSA6IHsgY3Vyc29yOiBcIm1vdmVcIiB9O1xuICAgICAgICB2YXIgaW5uZXJTdHlsZSA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXNpemFibGVTdHlsZSksIGN1cnNvclN0eWxlKSwgc3R5bGUpO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLm9mZnNldEZyb21QYXJlbnQsIGxlZnQgPSBfYi5sZWZ0LCB0b3AgPSBfYi50b3A7XG4gICAgICAgIHZhciBkcmFnZ2FibGVQb3NpdGlvbjtcbiAgICAgICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBkcmFnZ2FibGVQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiBwb3NpdGlvbi54IC0gbGVmdCxcbiAgICAgICAgICAgICAgICB5OiBwb3NpdGlvbi55IC0gdG9wLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJTkZPOiBNYWtlIHVuY29udG9yb2xsZWQgY29tcG9uZW50IHdoZW4gcmVzaXppbmcgdG8gY29udHJvbCBwb3NpdGlvbiBieSBzZXRQb3N0aW9uLlxuICAgICAgICB2YXIgcG9zID0gdGhpcy5zdGF0ZS5yZXNpemluZyA/IHVuZGVmaW5lZCA6IGRyYWdnYWJsZVBvc2l0aW9uO1xuICAgICAgICB2YXIgZHJhZ0F4aXNPclVuZGVmaW5lZCA9IHRoaXMuc3RhdGUucmVzaXppbmcgPyBcImJvdGhcIiA6IGRyYWdBeGlzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRHJhZ2dhYmxlLCB7IHJlZjogdGhpcy5yZWZEcmFnZ2FibGUsIGhhbmRsZTogZHJhZ0hhbmRsZUNsYXNzTmFtZSA/IFwiLlwiLmNvbmNhdChkcmFnSGFuZGxlQ2xhc3NOYW1lKSA6IHVuZGVmaW5lZCwgZGVmYXVsdFBvc2l0aW9uOiBkZWZhdWx0VmFsdWUsIG9uTW91c2VEb3duOiBvbk1vdXNlRG93biwgXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBvbk1vdXNlVXA6IG9uTW91c2VVcCwgb25TdGFydDogdGhpcy5vbkRyYWdTdGFydCwgb25EcmFnOiB0aGlzLm9uRHJhZywgb25TdG9wOiB0aGlzLm9uRHJhZ1N0b3AsIGF4aXM6IGRyYWdBeGlzT3JVbmRlZmluZWQsIGRpc2FibGVkOiBkaXNhYmxlRHJhZ2dpbmcsIGdyaWQ6IGRyYWdHcmlkLCBib3VuZHM6IGJvdW5kcyA/IHRoaXMuc3RhdGUuYm91bmRzIDogdW5kZWZpbmVkLCBwb3NpdGlvbjogcG9zLCBlbmFibGVVc2VyU2VsZWN0SGFjazogZW5hYmxlVXNlclNlbGVjdEhhY2ssIGNhbmNlbDogY2FuY2VsLCBzY2FsZTogc2NhbGUsIGFsbG93QW55Q2xpY2s6IGFsbG93QW55Q2xpY2ssIG5vZGVSZWY6IHRoaXMucmVzaXphYmxlRWxlbWVudCB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChSZXNpemFibGUsIF9fYXNzaWduKHt9LCByZXNpemFibGVQcm9wcywgeyByZWY6IHRoaXMucmVmUmVzaXphYmxlLCBkZWZhdWx0U2l6ZTogZGVmYXVsdFZhbHVlLCBzaXplOiB0aGlzLnByb3BzLnNpemUsIGVuYWJsZTogdHlwZW9mIGVuYWJsZVJlc2l6aW5nID09PSBcImJvb2xlYW5cIiA/IGdldEVuYWJsZVJlc2l6aW5nQnlGbGFnKGVuYWJsZVJlc2l6aW5nKSA6IGVuYWJsZVJlc2l6aW5nLCBvblJlc2l6ZVN0YXJ0OiB0aGlzLm9uUmVzaXplU3RhcnQsIG9uUmVzaXplOiB0aGlzLm9uUmVzaXplLCBvblJlc2l6ZVN0b3A6IHRoaXMub25SZXNpemVTdG9wLCBzdHlsZTogaW5uZXJTdHlsZSwgbWluV2lkdGg6IHRoaXMucHJvcHMubWluV2lkdGgsIG1pbkhlaWdodDogdGhpcy5wcm9wcy5taW5IZWlnaHQsIG1heFdpZHRoOiB0aGlzLnN0YXRlLnJlc2l6aW5nID8gdGhpcy5zdGF0ZS5tYXhXaWR0aCA6IHRoaXMucHJvcHMubWF4V2lkdGgsIG1heEhlaWdodDogdGhpcy5zdGF0ZS5yZXNpemluZyA/IHRoaXMuc3RhdGUubWF4SGVpZ2h0IDogdGhpcy5wcm9wcy5tYXhIZWlnaHQsIGdyaWQ6IHJlc2l6ZUdyaWQsIGhhbmRsZVdyYXBwZXJDbGFzczogcmVzaXplSGFuZGxlV3JhcHBlckNsYXNzLCBoYW5kbGVXcmFwcGVyU3R5bGU6IHJlc2l6ZUhhbmRsZVdyYXBwZXJTdHlsZSwgbG9ja0FzcGVjdFJhdGlvOiB0aGlzLnByb3BzLmxvY2tBc3BlY3RSYXRpbywgbG9ja0FzcGVjdFJhdGlvRXh0cmFXaWR0aDogdGhpcy5wcm9wcy5sb2NrQXNwZWN0UmF0aW9FeHRyYVdpZHRoLCBsb2NrQXNwZWN0UmF0aW9FeHRyYUhlaWdodDogdGhpcy5wcm9wcy5sb2NrQXNwZWN0UmF0aW9FeHRyYUhlaWdodCwgaGFuZGxlU3R5bGVzOiByZXNpemVIYW5kbGVTdHlsZXMsIGhhbmRsZUNsYXNzZXM6IHJlc2l6ZUhhbmRsZUNsYXNzZXMsIGhhbmRsZUNvbXBvbmVudDogcmVzaXplSGFuZGxlQ29tcG9uZW50LCBzY2FsZTogdGhpcy5wcm9wcy5zY2FsZSB9KSwgY2hpbGRyZW4pKSk7XG4gICAgfTtcbiAgICBSbmQuZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBtYXhXaWR0aDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgIG1heEhlaWdodDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgIHNjYWxlOiAxLFxuICAgICAgICBvblJlc2l6ZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgICAgIG9uUmVzaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgICAgIG9uUmVzaXplU3RvcDogZnVuY3Rpb24gKCkgeyB9LFxuICAgICAgICBvbkRyYWdTdGFydDogZnVuY3Rpb24gKCkgeyB9LFxuICAgICAgICBvbkRyYWc6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICAgICAgb25EcmFnU3RvcDogZnVuY3Rpb24gKCkgeyB9LFxuICAgIH07XG4gICAgcmV0dXJuIFJuZDtcbn0oUHVyZUNvbXBvbmVudCkpO1xuXG5leHBvcnQgeyBSbmQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-rnd/lib/index.js\n");

/***/ })

};
;